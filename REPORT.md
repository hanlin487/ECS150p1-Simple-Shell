# Project 1
## Command Data Structure Design
We implemented the command data structures by focusing on storing the arguments needed for the `execvp()` functions first which is the command and the string array of the command and the command arguments. This is done by simply storing the commands in the string array `command` that is in the `node` struct
The commands also serve as nodes in the linked list similar to how the commands are stored in project0.
However we also made a `list` struct that would have all the nodes inside it and this struct would act as the entire linked list that the nodes will be stored inside. The list doesn't really serve much of a purpose other than to contain the nodes/commands that the user will input.

## Functions
Most of the functions are basic helper functions that return values in the `list` or `node` structures like values in the command array, the amount of commands/the lenght of the command array, the head and tail of the linked list of commands, etc so they're pretty self-explanatory since they basically just return one line. `createNode` and `createList` initialize their respective structure variables and allocate memory for the variables that require memory allocation. The only complex function is `parse` which does a lot of the heavy lifting of the program. 

The parsing works by using `strok` and delimiting by a space `" "` in order to find the commands from the shell's command line and the arguments. Each argument in the command line separated by a space becomes a value in the string array `command` in the `node` structure and so for a command like `ls -l` the array would have elements `ls` and `-l` for it's first and second values. 
As for output redirection we use `strcmp` to see if the symbol is the `>` symbol and if we see that this is the case then instead of adding to the command string array we modify the `file` attribute of the command nodes instead to be the output destination specified by the value immediately after the `>` symbol. In the case of piping it actually doesn't separate the piped commands in the function itself but actually does the parsing in the main function so as to not complicate the original parsing function. The parsing method in the main function for when parsing is present is similar to that of the regualr parsing however it instead will go through and search for the `|` pipe symbol and parse and store (as explained above) each command in the pipe as its own object before moving on to other commands.

## Piping and Command Execution
The piping function we have is actually able to handle both single and piped commands so therefore in the fork+exec+wait structure we have the `pipeline()` function executed with the list of commands entered into the shell command line as the child process. Whether the command is something simple like `ls` or `ls -l | sort` the `pipeline()` function will be able to handle both. For the built-in commands like `cd`, `pwd`, and `set` the parent process will handle them and execute them. The piping logic is essentially the same as the piping example provided in the lecture in that it uses `dup2()` stream redirection to get the output of `command1` fed into the writing end of the pipe and then use `command2` which then reads the output of `command1` and after executing will have another output based on the input from the execution of `command1`. Then it'll just take the next command in the pipe, and repeat the process until all commands have gone through the pipe and there are no more commands to run. Kind of like `cmd1===cmd2===cmd3===cmd4===cmd5` and so on.

## Testing
Lots of testing was based off the example outputs detailed in the projects assignment and getting our own shell to emulate those. Then for the other remaining cases the shell was tested mainly with the simple testing script supplied as well as some of our own manual testing just to ensure there's no abnormal behavior by the shell.

## Resources
The most used resource is really the manual pages for the functions. A lot of the conceptual implementations are all from the lecture slides and from the class materials such as the professors example codes. The GNU docs provided in the `project1.html` page were also utilized to implement the more complicated processes like parsing and piping. Lots of the string manipulation comes from previous experience, but in the cases of looking for certain return values and behaviors, the manuals for the functions and the GNU pages were used.